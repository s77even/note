### 设计模式

设计模式六大设计原则：

<img src="https://img-blog.csdnimg.cn/20200411190736327.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMjA5MA==,size_16,color_FFFFFF,t_70" alt="å¨è¿éæå¥å¾çæè¿°" style="zoom:50%;" />



开放封闭原则：通过扩展软件实体来解决需求变化，而不是通过修改代码完成变化

里氏代换原则：使用的基类可以在任何地方使用继承的子类替换基类

依赖倒转原则：传递参数和关联关系中，尽量引用高层的抽象层类

接口隔离原则：使用多个隔离的接口比使用单个接口好，降低依赖，降低耦合

最少知道原则：一个对象应当对其他对象尽可能少的了解，类间解耦，低耦合高内聚

单一职责原则：一份方法只负责完成一件事情，降低耦合，提高可读性

<img src="https://img-blog.csdnimg.cn/20200411190730722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzEyMjA5MA==,size_16,color_FFFFFF,t_70" alt="å¨è¿éæå¥å¾çæè¿°" style="zoom:80%;" />



创建型模式  结构型模式  行为型模式

**创建型模式**

**单例模式**

保证一个类只有一个实例，只提供一个全局访问点

网站的计数器，程序日志，

创建模式：懒汉模式 饿汉模式  加锁 ， 双检查锁， once

优点：节约系统资源，避免对共享资源的多重占用，提供了对唯一实例的访问控制

缺点：不适用于变化的对象，单例类职责过重，

**工厂模式**

提供了一种创建对象的最佳方式，在工厂模式中，我们创建对象时不会对客户暴露创建逻辑，通过一个共同接口完成创建

工厂模式分为简单工厂、工厂方法和抽象工厂模式

工厂模式是最常用的实例化对象的模式，为后期维护提供了遍历

简单工厂：根据外界给定的信息决定应该创建那个具体类的对象，明确区分了各自的职责和权力

缺点：集中了所有实例的创建，出现问题整个系统都会受到影响，增加了系统的复杂度

工厂方法模式：核心工厂不在负责所有产品的创建，将具体的创建交给子类，核心类成为一个抽象工厂

抽象工厂模式：抽象工厂简单地说是工厂的工厂，抽象工厂可以创建具体工厂，由具体工厂来产生具体产品。

**建造者模式**

将一个复杂对象分解为多个简单对象，一步一步构建。

使用场景：需要生成的对象具有复杂的内部结构，内部属性本身相互依赖

优点：封装好，易扩展

缺点：有一定限制，维护成本大

工厂模式 和建造者模式 

建造者注重零部件的组装过程，工厂模式注重部件 的创建过程，两者可结合使用

**原型方法**



**结构型模式：**

**代理模式**

通过代理控制对象的访问，代理作为访问对象和目标对象之间的中介

优点：保护目标对象，可以扩展目标对象的功能，降低耦合，增加可扩展性

缺点：会造成系统更加复杂，处理速度由于多了中间层速度变慢

应用：异常处理，事务控制，权限控制

**适配器模式**

将一个类的接口转换成客户希望的另外一个接口。

优点：通过适配器可以透明的调用接口，解耦

缺点：增建了系统复杂度，降低了代码可读性

**桥接模式**

将抽象与实现分离，使他们可以独立变化。使用组合代替了继承。

优点：扩展能力强，实现细节对客户透明

缺点：增加了系统的理解和设计难度

**组合模式**

**装饰器模式：**

在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）

优点：装饰器是继承的补充，比继承灵活，动态的给对象扩充功能

缺点：会增加许多子类，是程序变得复杂

**外观模式：**

又叫门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性

优点：降低了子系统与客户端的耦合，对客户屏蔽了子系统组件，使用更加容易

缺点：增加新的子系统可能需要修改源代码，违反了开闭原则

**行为型模式**

**模板方法模式**

定义一个算法中的骨架，将算法的一些步骤延迟到子类中，子类不改变算法结构重定义某些步骤

优点：封装了不变部分，扩展可变部分，父类中提取了公共部分代码，便于代码复用

缺点：对于不同的实现都需要定义子类，增加了系统的复杂符

**策略方法模式**

定义了一系列的算法，并将每个算法封装起来，使他们可以互相替换，且算法的变化不会影响使用的客户

优点：多重条件语句不易维护，避免使用了多重条件语句

​			灵活扩展，提供了可供重用的算法族，避免了重复代码

缺点：客户端使用必须理解算法的区别，合适选择，会造成很多策略类，增加了维护难度

**命令模式**

将一个请求封装为一个对象，使发出的请求的责任和执行请求的责任分开。方便命令对象储存传递调用增加和管理

优点：通过引入中间件降低了系统的耦合，扩展良好，增加删除命令非常方便，

缺点：可能产生大量具体的命令类，增加了复杂性，增加了理解上的困难。

**责任链模式**

避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者形成一条链路，将请求沿着链路传递，直到被处理

优点：降低了对象之间的耦合，增加了系统的可扩展，增加了灵活性

缺点：不能保证请求一定被处理，对于较长的责任链，系统性能可能会造成较大的影响

**状态模式**

对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。

**观察者模式**

多个对象之间存在一对多的依赖关系，当一个对象发生改变时，依赖他的对象都被通知并更新。发布订阅

优点：降低了目标于观察者之间的耦合关系，目标和观察者之间建立了一套触发机制

缺点：可能出现循环引用，当观察者对象很多时，通知的发布会影响效率

**中介者模式**

定义一个中介来封装一系列对象的交互，是原有对象松耦合。

优点：降低了对象之间的耦合，使对象易于复用，提高了系统的灵活性。

缺点：对象越多，中介类的职责越庞大，不易于维护

**迭代器模式**

提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部标识。

优点：简化了类，封装性好

缺点：增加了类的个数，代码系统变得复杂

**访问者模式**



**备忘录模式**



**解释器模式**