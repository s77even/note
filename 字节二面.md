字节二面记录

**进程间通信**

**管道 匿名管道  命名管道**

常用的grep | 完成过滤其实就是使用到了管道，并且是匿名管道，将前面的输出作为后面的输入，匿名管道自行创建和销毁。

命名管道  mkfifo xxx 以文件的方式存在  允许无亲缘关系进程通信

**信号 信号量**

信号量是一种机制，用于控制多个进程对共享资源的访问

信号是一种用于通知进程某个事件，比如kill 0exit 9kill 2 结束int（ctrl c）

**消息队列**

**socket** 

**共享内存**

使多个进程可以访问同一块内存空间，需要加锁来进行同步和互斥

**mysql  索引查询的时间复杂度**

N个节点的B+树 M阶  查询时间复杂度为log（m）N 



**redis 持久化**

rdb持久化，save bgsave 同步和异步，bgsave，将数据快照保存道磁盘

aof持久化 将每一次数据的变化操作操作以日志的形式记录下来（总是 每秒 no）

sava是同步生成快照，会造成主业务的阻塞，bgsave是在后台进行，fork了子进程，先将数据及写入临时文件，写入成功后，替换之前的文件，用二进制存储来压缩。redis可以自动生成一个rdb文件，根据一个配置信息，监控一定时间记录变化的条数，来自动生成rdb文件来保存一个最新的数据。触发方式：全量复制，reload shutdown

aof持久化以日记的形式记录服务器所处理的每一个写和删除操作，查询操作不会记录，以文本方式记录，使用appendonly 来打开aof。aof重写：重写机制可以高效的保存每一条指令，减小aof文件的大小。fork直接读取库中的数据，进行重写。将一个key的多个数据，写成一条命令。触发重写：aof大小超出阈值，1M，增长率超过阈值

对比：RDB回复比较简单，如果数据量比较大，启动效率要大于AOF，但是可能会造成数据丢失，宕机的话，还没来得写入磁盘的数据会造成丢失。

​		AOF可以带来更高的数据安全性，还提供了AOF重写缓存来保证重写期间的数据安全，但是AOF要比rdb文件大，数据恢复会更慢。



golang gc 三色标记法 何时出发gc

三色标记法+混合写屏障：

三色标记： 白色灰色黑色 黑色是引用对象，灰色中间状态，白色是最后需要回收的对象。单纯的三色标记会丢失对象，如果一个黑色对象引用了一个白色对象，白色对象又被他之上的灰色对象丢失，这个白色对象就被GC了。因此引入了插入屏障和删除屏障：

插入屏障是指在在一个黑色对象引用白色对象时要把这个白色对象变为灰色。删除屏障：被删除的对象如果自身是灰色或者是白色，就标记为灰色，会多存活一轮gc。



**GC 触发：**

内存大小阈值，达到上次GC后两倍

固定时间gc ：默认2min触发一次

手动runtime.gc()



golang gmp  为什么有本地队列和抢夺还要有一个全局队列

gmp调度中当一个P的本地没有可执行的goroutine时会优先去全局队列中加锁获取，然后再去其他的P的本地队列中偷取。拥有全局队列主要是为了多个P的任务平衡，充分发挥多核的优势，一个P的本地队列满了之后，会将一部分的G放到全局队列中。去其他P的本地队列偷取其实是会影响到P的执行的，需要使用到CAS操作，所以优先级是最低的。

sync.map





字节三面



算法 求平方根

算法

蘑菇问题1 2 

