### Golang 内存分配

go内存分配算法主要来自google为C 语言开发的TCmalloc算法，核心思想就是把内存分为多级管理，从而降低锁的粒度，每个线程会维护自己的一个内存池，进行内存分配时优先从内存池中分配，当内存池不足时向全局内存池申请。

TcMalloc 

tcmalloc的分配的内存主要来源于：全局缓存堆，进程私有缓存，小容量的内存申请使用私有缓存，如果私有缓存不够，则从全局缓存堆中申请一部分作为私有缓存。大对象会直接从全局缓存中申请，至于大小的分界是32k。

##### 小对象分配

小对象内存分配默认会分配86个不同大小的块，这些块的大小不一致，内部采用单链表数组来组织内存，使用时遵循懒加载策略，等到使用时才进行初始化。

直接向mcache分配器申请，如果空间不足，向管理管理mcache相关规格的span链表申请，如果没有，就向mcentral申请对应规格span，如果依旧没有，就像heap申请分配，如果heap也用光了，就申请操作系统分配

tiny对象  0-16B   tidy对象分配器，在cache上直接申请分配，根据偏移查找合适

小对象   16B-32K  使用mspan进行内存分配，管理这不同规格的span



##### 大对象分配

大于32k的内存申请，属于大对象的分配，使用全局缓存堆直接分配，内存的组织方式也是通过单链表数组进行的，数据长度是256，每个链表的元素的大小是不同的，但都是4k（1page）的整数倍。





**mcache**  绑定在P上，每个P都有一个，mcache绑定，用来给协程分配对象存储空间

**mcache结构体中不需要使用锁**，每个P都只会同时执行一个G，不同P之间是内存隔离的，因此不存在竞争，所以分配速度很快。

mcache在初始化时是没有任何mspan资源的，在使用过程中会动态地申请，不断的去填充 alloc[numSpanClasses]*mspan，通过双向链表连接

**mspan**

**mcentral**   mcache动态申请mspan时，就是mcache向mcentral申请

mcentral结构体中存在锁，因为是公共资源，访问需要枷锁，同一个mcentral只负责一种规格的mspan

有两个双向链表，分别保存空闲未被使用的span和被使用未归还的span



**mheap**  mcentral中的空闲空间使用完时，会向mheap申请新的空间