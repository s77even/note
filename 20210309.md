### 20210309

**golang的异常 ：**

内置错误类型error，是一个接口类型，自定义的错误类型必须实现为error‘接口，接口内ERROR方法，这样调用总能够通过error）（）获取到具体的错误信息而不用关系错误的具体类型，标准库的errorf和errors.new 可以方便的创建error类型的变量

golang不支持try catch 来处理异常，引入了defer和panic，recover的方式

panic recover机制控制流作用在整个goroutine 调用栈中，当goroutine执行到panic 时，控制流开始在当前的goroutine调用栈向上回溯并执行每一个函数的defer，如果defer中遇到了recover就停止回溯，如果执行到最顶层的defer还没有recover，就输出调用栈信息然后退出。所以使用recover避免panic导致进程挂掉，recover必须放到defer中。



**golang字符串拼接的方式**

1 s3 := s1 + s2

2 s3 := fmt.Sprintf("%s%s",s1,s2)

3 join  S3 := strings.Join(str,"")

4定义一个bytes.Buffer类型  向buffer中写入字符串，获得凭借后的字符串

var bt bytes.buffer  

 bt.writestring(s1) 

bt.Writebuffer(s2)  

s3 := bt.string()

5  strings.Builder  和上面类似

var builder buffer.builder



**golang  inti()函数**

init()函数会在每个包完成初始化后自动执行，并且执行优先级比main函数高

init 函数通常被用来报的初始化，如初始化包中的变量，在main'之前完成。每个包可以拥有多个init函数，执行顺序是没有明确定义的。

init函数不能被其他函数调用，是main函数执行之前自动执行的。



**go mod**

1.11新增 的特征，1.12发布。GO111MODULE 现在默认开启。

**几种一致性算法的区别			**Paxos、Raft、ZAB

一致性：弱一致性：最终一致性 。

​				强一致性：

**paxos**  basic paxos算法实现困难，相对效率较低。

目前所有和paxos相关的协议，一定是基于multi paxos实现。

由于paxos的难以理解，出现了raft，raft以简单的实现和易理解为目标。





**令牌桶限流和漏桶限流**

漏桶算法能够强行限制数据的传输速率

令牌桶算法能够在限制数据的平均传输速度的而同时允许某种突发传输

在某种情况下，漏桶算法**并不有效的利用网络资源**，因为即便网络中没有发生拥塞，漏桶算法也不能是某个数据流达到端口速率，因此漏桶算法对于突发性的突发流量来说缺乏效率，令牌桶算法则能够满足这些突发性的流量，通常漏桶算法和令牌桶算法结合起来为网络流量提供更搞笑的控制。

令牌桶算法用来保护自己，主要用来对调用者频率进行限流，漏桶算法用来保护他人，保护所调用的系统。



平衡树：

AVL树：左右子树高度差不大于1，旋转调整

红黑树 ：颜色信息，一个节点非红即黑，根节点为黑色，叶子节点nil节点为黑色节点，红色节点的孩子是黑色节点，从任意节点到叶子结点具有相同数目的黑色节点。旋转和变色调整。

B树 ：多叉树

B+树：改进的B树



**堆**

理解上是一棵完全二叉树的形象，底层是数组实现。

堆的某个结点的值不大于或不小于其父节点的值。堆是一棵完全二叉树。



**锁**：互斥锁， 读写锁，

自旋锁 自旋锁获取不到锁 会循环尝试 不会阻塞进入内核态，减少了不必要的上下文切换。

非自旋锁 获取不到锁会进入组赛状态，进入内核状态，当获取到锁的时候需要从内核恢复，需要线程上下文交换。







**缓存穿透**：客户端去查询一个一定不存在的值，缓存中不存在，数据库中也不存在，由于缓存不命中，数据库也查不到不会写入缓存，所以每次查询都要去数据库查询，失去了缓存的意义

**解决方案**：

1 设置热点数据永不过期

2 加互斥锁，从缓存中读取缓存不存在的数据时，先获取锁再去读取数据库，读取到数据后更新缓存

**缓存击穿**：缓存击穿是指缓存中没有但数据库中有的数据，一般是缓存时间到期，这是由于并发量较大，同时读缓存没有读取导数据，又同时去数据库读取数据，造成数据库压力过大。

**解决方法：**

1 布隆过滤器

2 缓存空值

3 限流和熔断降级

**缓存雪崩**：缓存雪崩是指大批量数据达到过期时间，而查询数量巨大，造成数据库压力过大

**解决方案**：

1. 缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。
2. 如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。
3. 设置热点数据永远不过期。



外键关联：只有innodb引擎支持外键，一张表中有一个非主键的字段指向了别一张表中的主键，就将该字段叫做外键

​	**通过 foreign key (字段名) references 关联的表名(字段)**

外键约束的参照操作  CASCADE						从父表删除或更新，子表也跟着删除或者更新，级联的操作

​									SET NULL						从父表删除或者更新记录，并设置子表的外键列为NULL。

​									NO ACTION | RESTRICT	拒绝对父表做更新或者删除操作



左连接右连接内连接：left join rigth join in join

外连接会在等值连接的基础上加上主表中未匹配的数据，外连接显示的数据更多



**索引的类型：fulltext，hash，btree，rtree**

**索引的种类 ：普通索引 唯一索引  全文索引 主键索引 组合索引**





mysql字段  数值 字符串 日期时间

**数值**

TINYINT  1BYTE  (-128,127)(0 255)   用于小整数

smallint  2byte  (-32768 32767)(0 65535) 用于大整数值

mediumint 3

int interger  4 

bigint   8 

float   4        单精度浮点数

double 8  双精度浮点数

**字符串**

char 固定长字符串  不管存入几个字符 都将占用四个字节  存入字符数小于N 会以空格补上 最后查询时去掉 所以存储的字符串末尾不能有空格 ，char的字符串检索速度要快于varchar

varchar 变长字符串   末尾可以存储空格  存入的实际字符数+1字节 （n<=255 长度保存到一个字节）或2字节（n>255 保存长度需要两字节），可直接创建索引，test要制定前多少个字符，varchar查询更快

text 0- 65535字节  长文本数据

**日期时间类型**

date 	3字节    Y-M-D   1000 -01-01/9999-12-31

time	3			H:M:S		-838:/838

year	1			Y					1901-2155

datetime	8		Y-M-D H:M:S	1000-9999  

timestamp	4		YMD HMS			1970-2038  显示时间还和市区有关

**二进制**

bit    

bit（8）

分组 group by



**varchar 255 256**

行默认大小65535字节，可空标识位，1bit 8个组成一个字段，会占用行空间，所有行共享



