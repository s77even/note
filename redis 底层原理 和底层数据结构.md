### redis 底层原理 和底层数据结构

底层数据结构：

redisdb 表示了16个数据库结构，其中dict指针是一个字典，所有数据通过其进行索引

dict中也有一个哈希表dicthb，其中保存了所有数据节点dictentry

dictentry 实际的数据结构， 包括key val  next ，next用来解决哈希冲突，链表法

val指针又指向一个redisobj结构，保存了数据的值和type，enconding方式。lru等

![image-20210317161106944](C:\Users\wwwwwwl\AppData\Roaming\Typora\typora-user-images\image-20210317161106944.png)



**字符串**： 最基础常用的数据结构，类型的值可以有多种，字符串，数字，或者二进制等，**最大512MB**

（set get del incr decr append strlen）

字符串对象的内部编码有三种：**int**  **embstr** **raw** redis会根据当前的类型和长度来选择实现

如果一个字符串对象保存的是**整数**，并且这个整数值可以用**long**（4字节），使用int

如果字符串对象保存的是一个**字符串值**，并且字符串**长度小于等于44**字节（**sdshdr8**），会**用embstr实现**

如果字符串长度大于44字节，会变为raw实现

**embstr不需要进行指针二次寻址，字符串数据空间紧挨着redisobj结构体**，更好利用缓存。

**embstr只需要一次内存分配，raw需要两次内存分配，**

embstr对象实际上是**只读的**，如果该编码的**字符串长度增加需要重新分配内存**，会将**编码改为raw**。



**SDS 简单动态字符串**

3.2之前  

<img src="C:\Users\wwwwwwl\AppData\Roaming\Typora\typora-user-images\image-20210317164150194.png" alt="image-20210317164150194" style="zoom: 80%;" />

3.2 之后 做了优化，针对更小的对象存储造成的不必要的空间消耗，提出了5 8 16 32 64sdshdr

**为什么要用sds（针对c语言字符数组）**

C字符串会发生**缓冲区溢出**，SDS能够进行空间检查和动态扩容

C字符串**内存重分配**，性能损失严重。SDS**空间预分配**和**惰性释放**减少了内存重分配的次数

C字符串字符必须符合编码（不能包含空字符），SDS保存二进制，使用**len判断字符串结束**，遵循以空字符结尾的惯例，因此兼容C字符串函数

**时间复杂度** 

获取SDS长度: 由于SDS中提供了len属性，因此我们可以直接获取时间复杂度为O(1),C字符串为O(n)

SDS这种数据结构屏蔽了C字符串的一些缺点，可以提供安全高性能的字符串操作





**哈希**

（hget hset hdel hexist hlen hmget hmset hvals hgetall）

哈希对象用来存储一组数据对，每个数据对包含键值两部分。两种实现 **ziplist** **hashtable**

在保存数据量比较小的情况下，使用ziplist来保存哈希对象。

保存的键和值的**大小小于64字节**，字典中的**键值对的个数小于512个**

**ziplist**使用更加紧凑的结构实现了元素的连续存储 键在前值在后

**hashtabel**

使用**链表法**解决哈希冲突

  **rehash**  	dictht[0]->ht[1]  



**列表**

（lset   lpop lpush rpush rpop lrange lset  lrem）

列表支持存储一组有序的**可重复**的数据，可以获取指定范围的元素列表，最多存储**2^32-1**个元素

在**3.2**之前，内部实现使用ziplist和linklist，ziplist对个数长度有要求 64 512

3.2之后 使用**quicklist**作为内部实现。

链表的附加空间相对太高，前后指针就要占用16字节，每个节点内存单独分配，加剧内存的碎片化。

quciklist是ziplist和linklist的混合体，**将linkedlist按段切分，每一段使用ziplist紧凑存储，多个ziplist之间使用双指针连接**



**集合**

（sadd smembers sismember sinter sunion）

集合是**无序且唯一**的键值集合，存储顺序不会按照插入的先后顺序进行存储。

列表可以存储重复元素，集合只能存储非重复元素。

集合是无序方式存储的。

一个集合最多存储2^32-1个元素，支持多个集合的交集并集差集操作。

内部编码有两种：intset hashtabel

**intset** 整数集合是用于保存整数值的集合抽象数据结构，并且保证不会出现重复元素，按大小顺序存储。

- 集合对象保存的所有元素都是整数值
- 结合对象保存的元素数量不超过512个

整数集合的升级：当我们要将一个新元素添加到整数集合里面，并且新元素的类型比整数集合现有元素的类型都要长时，整数集合就需要进行升级。

整数集合升级的优点：提升灵活性，节约内存。不支持降低

超过元素个数512后，存储格式变为hashtable， **元素不在按照大小顺序存储**

可以设置这个边界 通过 **config set set-max-intset-entries 500** 可以更改



**有序集合**

(zadd zcount zrem zrange zrangebylex zrangebyscore zscore)

有序集合相比于集合多了一个排序属性score，对于有序集合每个存储元素相当于有元素和排序分值组成。

有序集合编码方式是由ziplist和skiplist组成的。

当数据比较少，有序集合是用的ziplist存储。

有序集合保存元素个数小于128个，保存的元素成员的长度都都小于64字节。

**skiplist**

对于一个单链表，查找链表中的某个数据就需要遍历一遍链表，查找效率低。

通过链表加多级索引的结构，来增加查找效率 通过空间换时间

索引是占内存的，原始链表中存储的是很大的对象时，索引节点只需要存储关键值和几个指针，优势被放大，相比之下索引的空间可以忽略，所以元素较多或者是存储元素较大时使用。