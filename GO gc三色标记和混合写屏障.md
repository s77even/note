### GO  GC三色标记和混合写屏障

v1.3 之前使用标记清除法

v1.5 三色标记法

v1.8 混合写屏障



##### 关键词：垃圾回收 自动释放 内存管理 三色标记法 STW（stop the world）



#### v1.3 标记清除法

<img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\image-20201218105036389.png" alt="image-20201218105036389" style="zoom:70%;" />

1、暂停业务逻辑（stw）

2、根据对象之间的引用关系找出可达对象和不可达对象，并标记需要保留的对象

3、清除未被标记的对象。

4、停止暂停，程序继续(或3 4 互换，缩短STW的范围，提升些许的效率。)

##### 缺点：

STW会让程序暂停，出现程序卡顿，影响了语言的性能（**）

标记需要扫描整个heap，复杂度较大

清除数据会产生heap碎片，造成heap不连续



#### v1.5 三色标记法

白色、灰色、黑色标记表（灰色标记是中间状态，最后回收所有白色对象）

##### 流程：

1、只要是新创建的对象都默认标记为白色

2、每次GC回收开始，从根节点开始遍历所有对象，把遍历到的白色对象放入灰色标记表中，标记为灰色

3、遍历灰色标记表，将灰色对象引用的对象从白色集合放入灰色集合，将原灰色对象放入黑色集合

4、重复（3），直到灰色集合中没有任何对象

5、最终结构中只有黑色对象和白色对象，并回收所有白色标记对象。



###### 如果三色标记中无STW，会出现对象丢失的现象

<img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\image-20201218112428179.png" style="zoom:50%;" />



##### 强弱三色不变式

强三色不变式：强制性不允许黑色对象引用白色对象（破坏条件1 ）

弱三色不变式： 黑色对象可以引用白色对象，必须保证白色对象存在其他灰色对象对他的引用，或者可达的它的链路上游存在灰色对象



##### 屏障机制（额外的判断机制）

插入屏障 ：对象被引用时触发的机制

删除屏障 ：对象被删除时触发的机制

###### 插入屏障

 在A对象引用B对象时，B对象被标记为灰色，将B挂在A下游。 满足强三色不变性：黑色不引用白色。

不足：针对栈上对象没有生成插入屏障 ， （性能损耗和实现复杂度），因此最后需要stw重新扫描一遍栈对象，大约需要10-100ms。

###### 删除屏障

被删除的对象如果自身为灰色或者白色，那么被标记为灰色。满足弱三色不变性：保护灰色对象到白色对象的路径不会断

不足：回收精度低。一个对象即使被删除了最后一个指向它的指针也依旧可以活过这一轮，在下一轮GC中才会被清理



#### v1.8 三色标记法+混合写屏障机制

具体操作：

1、GC开始**优先扫描全部栈对象**，所有可达对象**均标记为黑色**

2、GC期间，任何**在栈上创建的新对象均为黑色**

3、三色标记法扫描堆上对象

4、屏障机制：堆上被删除的对象标记为灰色，被添加的对象标记为灰色（栈上不启用屏障机制）

满足变形的弱三色不变式，结合了插入和删除写屏障的优点



######  使用场景1

对象被一个堆对象删除引用，称为一个栈对象的下游

<img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\image-20201218202121515.png" alt="image-20201218202121515" style="zoom:50%;" />



###### 使用场景2

对象a被一个栈对象b删除引用，成为另一个栈对象c的下游（不触发屏障机制，新建栈对象c直接被标记为黑色，直接引用栈对象a）



###### 使用场景3

对象被一个堆对象删除引用，成为另一个堆对象的下游



###### 使用场景4

对象从一个栈对象删除引用，称为另一个堆对象的下游





##### 总结

标记清除法

三色标记法

强三色不变

弱三色不变

屏障机制

插入写屏障

删除写屏障

三色标记法+混合写屏障机制

