###   Mysql

sql语句：DDL数据定义语言 DML数据操作语言 DQL数据查询语言 DCL数据控制语言

登录：mysql -uroot -ppassword

命令行结束 （;）



mysql架构：

C -> S -> 存储引擎

客户端向数据发送请求

客户端 ： 连接器 控制用户登录 连接

​				 分析器：词法语法分析

​				优化器：优化语句，规定执行流程CBO RBO成本 规则

​				执行器：SQL语句的实际执行

存储引擎：

**innodb架构**

innodb架构分为两块，内存和磁盘中的结构。使用日志现行策略。将数据修改先在内存中完成，并且将事务记录成redolog，转换为顺序IO高效的提交事务。日志先行是指，日志记录到达数据库后，对应的事务就可以返回给用户，表示事务完成。但是，这个事务可能还只在内存中修改完，并没有刷到磁盘上，内存是容易丢失的，如果数据刷盘前，宕机了，数据就丢失了。innodb通过redo日志来保证数据的一致性，因为redolog不可能无限制的增大，所以引入了checkpoint，定期检查，保证检查点之前的日志都写道磁盘，下次从检查点开始恢复。



缓存池：

innodb是基于磁盘存储的，磁盘的读写是较慢的，所以引入了缓存池，在内存中划分了一块区域通过内存的快速操作来弥补磁盘带来的性能损耗。

读操作：第一次读取就把读取的页加载到内存中，下次读取相同页直接到内存中读取，否则就去磁盘中读取并加载到内存。

写操作：首先修改内存中的数据，然后通过一个checkpoint机制刷新到磁盘

每个缓存池中的缓存页都有一些控制信息，包括页号，地址等，通过一个map映射关系来寻找到对应的缓存页进行读写操作。LRU free flush



**MYISAM 引擎** 

默认会在磁盘中产生三个文件 .frm表结构文件 .MYD数据文件  .MYI索引文件

单表最大支持的数据量 2^64   单表最多建立64个索引

**InnoDB引擎**

默认会在磁盘中产生两个文件  .frm表结构稳健  .idb 数据和索引存储表空间中

ACID （原子性 隔离性 一致性 持久性） 支持事务 支持行级锁   



区别：

 InnoDB 支持事务，MyISAM 不支持事务

nnoDB 支持外键，而 MyISAM 不支持

 InnoDB 是聚集索引，MyISAM 是非聚集索引

. InnoDB 不保存表的具体行数，myisam保存行数，

 InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁，innodb会产生死锁



在innodb中，数据被划分成若干页，以页作为交互的基本单位，一页大小默认为16KB，也就是说从磁盘中读取数据数据到内存的话一次最小读取一页



**索引的类型：fulltext，hash，btree，rtree**



**索引的种类 ：普通索引 唯一索引  全文索引 主键索引 组合索引**

普通索引：用于加速查询，没有特别限制

唯一索引:索引列的值必须唯一，但允许有空值，

主键索引：特殊的唯一索引，一个表只能有一个主键，一般在建表的时候同时创建主键索引

组合索引：多个字段联合创建的索引，只有在查询条件中使用创建索引时的第一个字段，索引才会使用，左前缀原则

全文索引：

 

 innodb推荐表必须建立主键，并且要使用整形的自增主键。

innodb 使用聚簇索引通过主键来整合和构建所有数据之间的b+树，如果没有主键 innodb会自动选择一个合适的列值来作为主键，但这个选择是好费时间和性能的。推荐使用整形的自增，整形查找比较效率高，





**添加记录**

insert tbl name value 按照建表的顺序依次赋值

INSERT tbl_name(字段名称,...) VALUES(值,...) 指指定字段赋值

INSERT tbl_name SET 字段名称=值,...;

**修改记录**

UPDATE tbl_name SET 字段名称=值,字段名称=值 [WHERE 条件]	如果不添加条件，整个表中的记录都会被更新

**删除数据**

DELETE FROM tbl_name [WHERE 条件]

DELETE 清空数据表的时候不会重置AUTO_INCREMENT的值，可以通过ALTER 语句将其重置为1

**彻底清空数据表**		TRUNCATE [TABLE] tbl_name;

清除表中所有记录		会重置AUTO_INCREMENT的值

**查询记录**

SELECT * FROM tbl_name;	*所有字段

SELECT 字段名称,... FROM tbl_name		指定字段的信息

 SELECT 字段名称,... FROM db_name.tbl_name;

**WHERE 条件**

比较运算符 			  > >= < <= != <> <=>		<=>可以检测NULL值

IS [NOT] NULL			检测值是否为NULL或者NOT NULL

指定范围				[NOT] BETWEEN ... AND

指定集合				[NOT] IN(值,...)

逻辑运算符			AND OR

匹配字符				[NOT] LIKE			%   任意长度的字符串    __ 任意一个字符

  **GROUP BY 分组		**把值相同放到一个组中，最终查询出的结果只会显示组中一条记录

HAVING子句对分组结果进行二次筛选

ORDER BY 排序  	ORDER BY 字段名称 ASC|DESC

LIMIT 限制结果集显示条数



**多表查询**

**内连接的形式**

​	查询两个表中符合连接条件的记录		

SELECT 字段名称,... FROM tbl_name1
INNER JOIN tbl_name2
ON 连接条件

**外连接的形式**

左外连接	先**显示左表**中的全部记录，再**去右表中查询**复合条件的记录，不符合的以NULL代替

SELECT 字段名称,... FROM tbl_name1
LEFT [OUTER]  JOIN tbl_name2
ON 条件;

右外连接	先**显示右表**中的全部记录，再去**左表中查询**复合条件的记录，不符合的以NULL代替

SELECT 字段名称,... FROM tbl_name1
 RIGHT [OUTER] JOIN tbl_name2
ON 条件;



**外键约束**

只有InnoDB存储引擎支持外键

子表的外键字段和主表的主键字段类型要**相似**；如果是**数值型要求一致**，并且无符号也要一致；如果是**字符型**，要求**类型一致，长度可以不同**

外键列和参照列必须创建索引，如果外键不存在索引的话，mysql将自动创建索引，参照列不存在索引的话，mysql不会自动创建索引

外键约束的参照操作  CASCADE						从父表删除或更新，子表也跟着删除或者更新，级联的操作

​									SET NULL						从父表删除或者更新记录，并设置子表的外键列为NULL。

​									NO ACTION | RESTRICT	拒绝对父表做更新或者删除操作

动态删除外键

ALTER TABLE tbl_name
DROP FOREIGN KEY fk_name;



**子查询**

内层语句查询的结果可以做为外层语句查询的条件

SELECT 字段名称 FROM tbl_name WHERE col_name=(SELECT col_name FROM tbl_name)

**联合查询**

SELECT 字段名称,... FROM tbl_name1 
UNION
SELECT 字段名称... FROM tbl_name2;

SELECT 字段名称,... FROM tbl_name1 
UNION ALL
SELECT 字段名称... FROM tbl_name2;

**UNION ALL 是简单的合并，UNION会去掉表中重复记录**



四种隔离级别：

读未提交：能够读取到未提交事务对数据记录的操作，会出现脏读

读已提交：只有已经提交事务的更改操作才能被看到，会出现不可重复读和幻读

可重复读： 

串行读



事务：一系列sql语句，要么成功要么全部失败。		ACID（）

原子性 ：事务中的所有操作作为整体，原子不可分割，要么全部成或全部失败。undolog 回滚日志

隔离性：并发执行的事务不会互相影响。

一致性：事务的执行结果必须让数据库从一个一致状态到另一个一致状态

持久性：事物一旦提交，对数据库的更新就是持久的，故障不会导致数据的丢失。redolog



**MVCC**

是一种用来**解决读-写冲突**的**无锁并发控制**，也就是为事务**分配单向增长的时间戳**，为每个修改保存一个版本，版本与事务时间戳关联，**读操作只读该事务开始前的数据库的快照**

版本链：聚簇索引记录中包含两个必要的隐藏列  

trx-id   每次对某条记录进行改动时，都会把**对应的事务id赋值给trx_id隐藏列**。

roll pointer	每次对某条记录进行改动时，这个隐藏列会存一个指针，可以**通过这个指针找到该记**

**录修改前的信息。**

对于**使用READ UNCOMMITTED**隔离级别的事务来说，**直接读取记录的最新版本**就好了，对于使用

**SERIALIZABLE隔离级别**的事务来说，**使用加锁的方式**来访问记录。对于使用**READ COMMITTED和**

**REPEATABLE READ隔离级别**的事务来说，就需要用到我们上边所说的版本链了，核心问题就是：需要**判断一下**

**版本链中的哪个版本是当前事务可见的。**



**ReadView****已提交读和可重复读的区别就在于它们生成ReadView的策略不同**。

m-ids  	在生成ReadView时当前系统中活跃的读写事务的事务id列表。

min-trx-id	 在生成ReadView时当前系统中活跃的读写事务中最小的事务id，

 max-trx-id 	生成ReadView时系统中应该分配给下一个事务的id值

creator-trx-id	生成该ReadView的事务的事务id



读已提交:



MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程。可以使不同事务的读-写、写-读操作并发执行，从而提升系统性能。

**READ COMMITTD在每一次进行普通SELECT操作前都会生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查询操作都重复使用这个ReadView就好了**





**锁**

读锁：共享锁，S锁

写锁：排它锁，X锁



**读操作**：

in share mode    将查找到的数据加上一个S锁，允许其他事务继续获取这些记录的S锁，不能获取这些记录的X锁

读出数据后，其他事务不能修改，但是自己也不一定能修改，因为其他事务也可以使用**select ... lock**

**in share mode** 继续加读锁

for  update	将查找到的数据加上一个X锁，不允许其他事务获取这些记录的S锁和X锁。

读出数据后，其他事务即不能写，也不能加读锁，那么就导致只有自己可以修改数据。

**写操作**

删除一条数据时，先对记录加X锁，再执行删除操作

插入一条记录时，会先加隐式锁来保护这条新插入的记录在本事务提交前不被别的事务访问到



行锁：

LOCK_REC_NOT_GAP：单个行记录上的锁。

LOCK_GAP：间隙锁，锁定一个范围，但**不包括记录本身**。GAP锁的目的，是为了防止同一事务

的两次当前读，出现幻读的情况。

LOCK_ORDINARY：临建锁  锁定一个范围，并且**锁定记录本身**。对于行的查询，都是采用该方法，主要

目的是解决幻读的问题



表锁：innodb的优点是行锁，性能跟高



IS锁，IX锁 意向锁

IS、IX锁是表级锁，它们的提出仅仅为了**在之后加表级别的S锁和X锁时可以快速判断表中的记录是否被上锁，**以避免用遍历的方式来查看表中有没有上锁的记录。

悲观锁

数据库的行锁，认为数据库会发生并发冲突，上来就先将数据锁住，直到当前事务提交了。

乐观锁

不需要枷锁，每次读取获取表中的版本号，如果开始更新时，版本号一样就更新。多数基于数据版本（Version）记录机制实现，



死锁：四个条件：互斥，循环等待，不剥夺，请求与保持

死锁检测：50s  检测到，会选择导致死锁的事务中选择一个权重比较小的事务来回滚

权重值由该事务影响的行数决定

避免死锁：

以固定的顺序访问，大事务拆解







### SQL优化

