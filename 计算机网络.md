### 计算机网络

![image-20210301163902030](C:\Users\seven\AppData\Roaming\Typora\typora-user-images\image-20210301163902030.png)



应用层协议： http dns(域名到ip 的转换) ftp 

传输层：TCP UDP	

网络层：IP ICMP（差错报文） IGMP（网际组管理） DHCP（动态IP） ARP（ip：mac 映射）

数据链路层：IEEE 





![image-20210314152547193](C:\Users\seven\AppData\Roaming\Typora\typora-user-images\image-20210314152547193.png)



三次握手：第一次发送连接请求，SYN=1.seq=x

​					服务器收到后回复SYN=1，ACK=1.ack=x+1,seq=y，

​					客户端收到回复后发送ACK=1,ack=y+1,seq=x+1

SYN 洪泛攻击

利用三次握手的特性，攻击者发送第一次握手的请求数据包，服务器收到后回复响应请求，攻击者不对其进行确认，导致TCP连接处于半连接状态。服务器收不到确认，会超时重传 重复发送ACK给攻击者，浪费了大量服务器资源。攻击者会对服务器发送大量这种TCP请求，导致服务器消耗大量内存和CPU。  解决：设置超时，快释放，SYN cookie



四次挥手

 <img src="C:\Users\seven\AppData\Roaming\Typora\typora-user-images\image-20210314154653509.png" alt="image-20210314154653509" style="zoom:80%;" />

四次挥手：wireshark

​				客户端发送连接释放报文段，停止发送数据，FIN=1，seq=u，主动关闭 TCP连接，进入FIN-WAIT-1

​				服务器端回送一个确认报文，客户端进入FIN-WAIT-2,ACK=1，seq=v,ack=u+1

​				服务端发送完数据，发出连接释放报文段，主动关闭TCP连接。FIN=1,ACK=1，seq=w，ack=u+1

​				客户端回送一个确认报文段，等待2msl 连接关闭 ACK=1,seq=u+1，ack=w+1

### 2msl

MSL是报文在网络中的最大存活时间，ACK发送到服务端时长最长为1msl，超过这个时间会触发超时重传，B重发的fin在经过一个msl到达客户端，如果收到了 就能再次发送ack 保证双方正确关闭。



## http和https的区别

超文本传输协议HTTP协议被用于在Web浏览器和网站服务器之间传递信息，HTTP协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。

为了解决HTTP协议的这一缺陷，需要使用另一种协议：安全套接字层超文本传输协议HTTPS，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。



### http的请求类型：

GET 请求指定的页面信息，

HEAD 向服务器索求与get请求一致的响应，响应体不会被返回，获取响应头的元信息

POST 向指定资源提交数据进行处理请求，提交表单或上传文件

PUT 向指定资源位置上传最新内容

DELETE 请求服务器删除URl资源

TRACE 回显服务器收到的请求，用来测试

OPTIONS 允许客户端查看服务端的性能





# HTTP keep-alive和TCP keepalive

**在双方长时间未通讯时，如何得知对方还活着？如何得知这个TCP连接是健康且具有通讯能力的？**

TCP的保活机制就是用来解决此类问题，这个机制我们也可以称作：keepalive。保活机制默认是关闭的，TCP连接的任何一方都可打开此功能。有三个主要配置参数用来控制保活功能。

如果在一段时间（**保活时间：tcp_keepalive_time ** 7200s）内此连接都不活跃，开启保活功能的一端会向对端**发送一个保活探测报文**。

- 若对端正常存活，且连接有效，对端必然能收到探测报文并进行响应。此时，发送端收到响应报文则证明TCP连接正常，重置保活时间计数器即可。

- 若由于网络原因或其他原因导致，发送端无法正常收到保活探测报文的响应。那么在一定**探测时间间隔（tcp_keepalive_intvl  75s）**后，将继续发送保活探测报文。直到收到对端的响应，或者达到配置的**探测循环次数上限（tcp_keepalive_probes  9）**都没有收到对端响应，这时对端会被认为不可达，TCP连接随存在但已失效，需要将连接做中断处理。

  

http协议是一个运行在TCP协议之上的无状态的应用层协议。它的特点是：客户端的每一次请求都要和服务端创建TCP连接，服务器响应后，断开TCP连接。下次客户端再有请求，则重新建立连接。

在早期的http1.0中，默认就是上述介绍的这种“请求-应答”模式。这种方式频繁的创建连接和销毁连接无疑是有一定性能损耗的。所以引入了**keep-alive**机制。http1.0默认是关闭的，通过http请求头设置“connection: keep-alive”进行开启；http1.1中默认开启，通过http请求头设置“connection: close”关闭。

**keep-alive**机制：若开启后，在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间内，如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在接下来一段时间内还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗。



### https  http+ssl

非对称加密：任何经过A公钥加密的信息，只有A的私钥才能解密。任何有公钥的人都可以确认信息被私钥机密。RSA DSA

对称加密：加密和解密是同一把秘钥  加密速度快  AES	 

ca认证：ca对服务器证书用自己的私钥进行签字认证，任何有ca认证的机构公钥的人，都能知道证书认证过

**中间人攻击**

https请求过程：

1 客户端向服务端发出连接请求     服务端返回ca证书和自己的公钥

2 客户端验证ca证书合法性    创建随机秘钥使用公钥机密

3 服务端使用公钥对随机秘钥进行解密  得到随机秘钥 

3 用随机秘钥进行加密通信



#### 客户端发送第一个syn服务器没有接收到，产生了丢包了怎么办？

客户端发送 SYN 开启了三次握手，之后客户端连接的状态是 SYN_SENT，然后等待服务器回复 ACK 报文。正常情况下，服务器会在几毫秒内返回 ACK，但如果客户端迟迟没有收到 ACK 会怎么样呢？客户端会重发 SYN，重试的次数由 tcp_syn_retries 参数控制，**默认是 6 次**：第 1 次重试发生在 1 秒钟后，**接着会以翻倍的方式在第 2、4、8、16、32 秒共做 6 次重试**，最**后一次重试会等待 64 秒**，如果仍然没有返回 ACK，才会终止三次握手。



### Negle算法

避免发送小数据包.出现了nagle算法.

算法定义:任意时刻，最多**只能有一个未被确认的小的分组**,在该分组的ack收到前,会收集其他的小分组,然后收到ack后,一起发过去.

1.如果发送内容>=MSS,立即发送

2.如果没有未被ack的包,立即发送

3.如果有包未被ack,那么缓存起来,当收到ack后,立即发送缓存的内容

tcp默认会开启Nagle算法,因此对小包的发送,有时候会延迟严重.

我们可以使用参数**tcp_nodelay**=true,关闭nagle算法



tcp 保证可靠性的机制

1 确认应答机制 2 校验和 3 序列号 4 超时重传 5 三次握手四次挥手 6 流量控制 7 拥塞控制

### 流量控制

滑动窗口    TCP报文段首部中有一个16位窗口长度

流量控制解决了 两台主机之间因传送速率而可能引起的丢包问题

### 拥塞控制的四种算法

网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题

慢开始 快重传 拥塞避免 快恢复

慢启动+拥塞避免：tcp建立连接关系后 后维护一个拥塞窗口， 刚开始值为1，并设置慢开始门限。执行慢开始算法，发送方收到每一个接收方的确认后，将窗口增大，直到窗口到达慢开始门限，启动拥塞避免算法。降低窗口的增大速率，降低网络压力，如果网络还是发生了超时重传，这个时候就重新开始慢开始算法，并且降低慢开始门限（一半）。

快重传+快恢复：个别报文在网络中丢失，网络并未发生阻塞，发送方超时重传，误认为网络阻塞，启动慢开始算法，降低了网络的传输效率

​			 在发送方超时重传前，尽快进行重传。收到三个连续的重复确认就触发重传。收到三个重复确认，就知道是报文丢失，开始执行快恢复算法，将慢开始门限和拥塞窗口调整为当前的一半，开始拥塞避免